



# 使用Docker

1.   拉取镜像

   ```
   docker pull mcr.microsoft.com/mssql/server
   ```

2.  启动镜像

   ```
   docker run -e "ACCEPT_EULA=Y" -e "SA_PASSWORD=PaSSword12!" -p 1433:1433 -d mcr.microsoft.com/mssql/server
   ```

   

# Nuget 包

1.  Microsoft.EntityFrameworkCore
2.  Microsoft.EntityFrameworkCore.SqlServer
3.  Microsoft.EntityFrameworkCore.Tools  



# Database Migration

数据迁移

1. ```
   add-migration initialMigration
   ```

更新数据库

1. ```
   update-database 
   ```

   

   ## 命令行使用 dotnet tool install --global dotnet-ef

   1. ```
      dotnet ef  migrations add dataseeding
      ```

      

   2. ```
      dotnet ef  database update
      ```

      

   

# Docker使用Mysql

1.  拉取mysql镜像

   ```
   docker pull mysql:latest
   ```

2. 运行mysql

   ```
   docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql (镜像名称)
   ```

3. 安装Mysql扩展包工具： Pomelo.EntityFrameworkCore.Mysql 

   **注意**：不要使用Oracle官方自带的工具，据说很烂

4.  StartUp.cs  替换为使用Mysql

#  Mysql数据迁移

```
1.	dotnet ef migrations add MysqlInit
2.  dotnet ef database update
```



# AutoMapper  

1.  AutoMapper.Extensions.Microsoft.DependencyInjection

2.  注入IOC容器  

   ```
   services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());
   ```

3.  映射

   ```
    var touristRouteDto = _mapper.Map<TouristRouteDto>(routes)
   ```

4.  类似的框架

   AutoMapper   **VS**  EmitMapper  **VS**  ValueInjecter  **VS**  GraphQL 

# 数据验证规则

1. 尽量不要放在数据模型里验证，操作数据库时可能引发问题，应该放在DTO文件中。



# 自定义数据验证

1.   IValidatableObject 可实现自定义的数据验证规则，例：多个属性捆绑验证：

   ```c#
           public IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
           {
               if (Title == Description)
               {
                   yield return new ValidationResult("Title cannot equals Description",
                   new[] { nameof(TouristRouteForCreationDto) });
               }
           }
   ```



# 类级别的数据验证

1.  建类	

   ```
       public class TouristRouteTitleMustDifferWithDescriptionAttribute : ValidationAttribute
       {
           protected override ValidationResult IsValid(object value, ValidationContext validationContext)
           {
               var touristRouteDto = validationContext.ObjectInstance as TouristRouteForCreationDto;
               
               if (touristRouteDto.Title == touristRouteDto.Description)
               {
                   return new ValidationResult("Title cannot equals Description class", new[] { nameof(TouristRouteForCreationDto) });
               }
   
               return ValidationResult.Success;
           }
       }
   ```

   

2.  使用

   ```
   [TouristRouteTitleMustDifferWithDescription]
   public class TouristRouteForCreationDto{}
   ```



# 返回正确的响应码

1.  400 转化成422 ， Startup.cs   =》  ConfigureServices 

   ```
               services.AddControllers()
               // 验证数据是否非法
               .ConfigureApiBehaviorOptions(setupAction =>
               {
                   setupAction.InvalidModelStateResponseFactory = context =>
                   {
                       var problemDetail = new ValidationProblemDetails(context.ModelState)
                       {
                           Type = "都行",
                           Title = "数据验证失败",
                           Status = StatusCodes.Status422UnprocessableEntity,
                           Detail = "请看详细说明",
                           Instance = context.HttpContext.Request.Path
                       };
                       problemDetail.Extensions.Add("traceId", context.HttpContext.TraceIdentifier);
                       return new UnprocessableEntityObjectResult(problemDetail)
                       {
                           ContentTypes = { "application/problem+json" }
                       };
                   };
               });
   ```

   
